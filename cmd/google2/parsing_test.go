package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"testing"
)

func TestHardest(t *testing.T) {
	var flags parser.Mode
	flags |= parser.SkipObjectResolution
	files := []string{
		"/usr/lib/go/src/go/ast/ast.go",
		"/usr/lib/go/src/go/ast/commentmap.go",
		"/usr/lib/go/src/go/ast/ast_test.go",
		"/usr/lib/go/src/go/ast/commentmap_test.go",
		"/usr/lib/go/src/go/ast/example_test.go",
		"/usr/lib/go/src/go/ast/filter.go",
		"/usr/lib/go/src/go/ast/filter_test.go",
		"/usr/lib/go/src/go/ast/import.go",
		"/usr/lib/go/src/go/ast/issues_test.go",
		"/usr/lib/go/src/go/ast/print.go",
		"/usr/lib/go/src/go/ast/print_test.go",
		"/usr/lib/go/src/go/ast/resolve.go",
		"/usr/lib/go/src/go/ast/scope.go",
		"/usr/lib/go/src/go/ast/walk.go",
		"/usr/lib/go/src/go/ast/walk_test.go",
		"/usr/lib/go/src/go/types/alias.go",
		"/usr/lib/go/src/go/types/api.go",
		"/usr/lib/go/src/go/types/api_predicates.go",
		"/usr/lib/go/src/go/types/api_test.go",
		"/usr/lib/go/src/go/types/array.go",
		"/usr/lib/go/src/go/types/assignments.go",
		"/usr/lib/go/src/go/types/badlinkname.go",
		"/usr/lib/go/src/go/types/basic.go",
		"/usr/lib/go/src/go/types/builtins.go",
		"/usr/lib/go/src/go/types/builtins_test.go",
		"/usr/lib/go/src/go/types/call.go",
		"/usr/lib/go/src/go/types/chan.go",
		"/usr/lib/go/src/go/types/check.go",
		"/usr/lib/go/src/go/types/check_test.go",
		"/usr/lib/go/src/go/types/commentMap_test.go",
		"/usr/lib/go/src/go/types/const.go",
		"/usr/lib/go/src/go/types/context.go",
		"/usr/lib/go/src/go/types/context_test.go",
		"/usr/lib/go/src/go/types/conversions.go",
		"/usr/lib/go/src/go/types/decl.go",
		"/usr/lib/go/src/go/types/errorcalls_test.go",
		"/usr/lib/go/src/go/types/errors.go",
		"/usr/lib/go/src/go/types/errors_test.go",
		"/usr/lib/go/src/go/types/errsupport.go",
		"/usr/lib/go/src/go/types/eval.go",
		"/usr/lib/go/src/go/types/eval_test.go",
		"/usr/lib/go/src/go/types/example_test.go",
		"/usr/lib/go/src/go/types/expr.go",
		"/usr/lib/go/src/go/types/exprstring.go",
		"/usr/lib/go/src/go/types/exprstring_test.go",
		"/usr/lib/go/src/go/types/format.go",
		"/usr/lib/go/src/go/types/gccgosizes.go",
		"/usr/lib/go/src/go/types/gcsizes.go",
		"/usr/lib/go/src/go/types/generate.go",
		"/usr/lib/go/src/go/types/generate_test.go",
		"/usr/lib/go/src/go/types/gotype.go",
		"/usr/lib/go/src/go/types/hilbert_test.go",
		"/usr/lib/go/src/go/types/index.go",
		"/usr/lib/go/src/go/types/infer.go",
		"/usr/lib/go/src/go/types/initorder.go",
		"/usr/lib/go/src/go/types/instantiate.go",
		"/usr/lib/go/src/go/types/instantiate_test.go",
		"/usr/lib/go/src/go/types/interface.go",
		"/usr/lib/go/src/go/types/issues_test.go",
		"/usr/lib/go/src/go/types/iter.go",
		"/usr/lib/go/src/go/types/labels.go",
		"/usr/lib/go/src/go/types/literals.go",
		"/usr/lib/go/src/go/types/lookup.go",
		"/usr/lib/go/src/go/types/lookup_test.go",
		"/usr/lib/go/src/go/types/main_test.go",
		"/usr/lib/go/src/go/types/map.go",
		"/usr/lib/go/src/go/types/methodset.go",
		"/usr/lib/go/src/go/types/methodset_test.go",
		"/usr/lib/go/src/go/types/mono.go",
		"/usr/lib/go/src/go/types/mono_test.go",
		"/usr/lib/go/src/go/types/named.go",
		"/usr/lib/go/src/go/types/named_test.go",
		"/usr/lib/go/src/go/types/object.go",
		"/usr/lib/go/src/go/types/object_test.go",
		"/usr/lib/go/src/go/types/objset.go",
		"/usr/lib/go/src/go/types/operand.go",
		"/usr/lib/go/src/go/types/package.go",
		"/usr/lib/go/src/go/types/pointer.go",
		"/usr/lib/go/src/go/types/predicates.go",
		"/usr/lib/go/src/go/types/README.md",
		"/usr/lib/go/src/go/types/recording.go",
		"/usr/lib/go/src/go/types/resolver.go",
		"/usr/lib/go/src/go/types/resolver_test.go",
		"/usr/lib/go/src/go/types/return.go",
		"/usr/lib/go/src/go/types/scope.go",
		"/usr/lib/go/src/go/types/scope2.go",
		"/usr/lib/go/src/go/types/scope2_test.go",
		"/usr/lib/go/src/go/types/selection.go",
		"/usr/lib/go/src/go/types/self_test.go",
		"/usr/lib/go/src/go/types/signature.go",
		"/usr/lib/go/src/go/types/sizeof_test.go",
		"/usr/lib/go/src/go/types/sizes.go",
		"/usr/lib/go/src/go/types/sizes_test.go",
		"/usr/lib/go/src/go/types/slice.go",
		"/usr/lib/go/src/go/types/stdlib_test.go",
		"/usr/lib/go/src/go/types/stmt.go",
		"/usr/lib/go/src/go/types/struct.go",
		"/usr/lib/go/src/go/types/subst.go",
		"/usr/lib/go/src/go/types/termlist.go",
		"/usr/lib/go/src/go/types/termlist_test.go",
		"/usr/lib/go/src/go/types/token_test.go",
		"/usr/lib/go/src/go/types/tuple.go",
		"/usr/lib/go/src/go/types/type.go",
		"/usr/lib/go/src/go/types/typelists.go",
		"/usr/lib/go/src/go/types/typeparam.go",
		"/usr/lib/go/src/go/types/typeset.go",
		"/usr/lib/go/src/go/types/typeset_test.go",
		"/usr/lib/go/src/go/types/typestring.go",
		"/usr/lib/go/src/go/types/typestring_test.go",
		"/usr/lib/go/src/go/types/typeterm.go",
		"/usr/lib/go/src/go/types/typeterm_test.go",
		"/usr/lib/go/src/go/types/typexpr.go",
		"/usr/lib/go/src/go/types/under.go",
		"/usr/lib/go/src/go/types/unify.go",
		"/usr/lib/go/src/go/types/union.go",
		"/usr/lib/go/src/go/types/universe.go",
		"/usr/lib/go/src/go/types/util.go",
		"/usr/lib/go/src/go/types/util_test.go",
		"/usr/lib/go/src/go/types/validtype.go",
		"/usr/lib/go/src/go/types/version.go",
	}

	for _, file := range files {
		var fset token.FileSet
		file_ast, _ := parser.ParseFile(&fset, file, nil, flags)
		func_declarations := file_ast.Decls
		for _, declaration := range func_declarations {
			switch v := declaration.(type) {
			case *ast.FuncDecl:
				{
					function := parse_ast_func_decl(&fset, v)
					fmt.Println(function)
				}
			}
		}
	}
}
func TestQueryInput(t *testing.T) {
	var flags parser.Mode
	flags |= parser.SkipObjectResolution
	queries := []string{
		"func hello(foo int) int{return foo}",
		"func (c *Comment) Pos() (token.Pos)",
		"func (c *Comment) End() (token.Pos)",
		"func (g *CommentGroup) Pos() (token.Pos)",
		"func (g *CommentGroup) End() (token.Pos)",
		"func isWhitespace(ch byte) (bool)",
		"func stripTrailingWhitespace(s string) (string)",
		"func (g *CommentGroup) Text() (string)",
		"func isDirective(c string) (bool)",
		"func (f *Field) Pos() (token.Pos)",
		"func (f *Field) End() (token.Pos)",
		"func (f *FieldList) Pos() (token.Pos)",
		"func (f *FieldList) End() (token.Pos)",
		"func (f *FieldList) NumFields() (int)",
		"func (x *BadExpr) Pos() (token.Pos)",
		"func (x *Ident) Pos() (token.Pos)",
		"func (x *Ellipsis) Pos() (token.Pos)",
		"func (x *BasicLit) Pos() (token.Pos)",
		"func (x *FuncLit) Pos() (token.Pos)",
		"func (x *CompositeLit) Pos() (token.Pos)",
		"func (x *ParenExpr) Pos() (token.Pos)",
		"func (x *SelectorExpr) Pos() (token.Pos)",
		"func (x *IndexExpr) Pos() (token.Pos)",
		"func (x *IndexListExpr) Pos() (token.Pos)",
		"func (x *SliceExpr) Pos() (token.Pos)",
		"func (x *TypeAssertExpr) Pos() (token.Pos)",
		"func (x *CallExpr) Pos() (token.Pos)",
		"func (x *StarExpr) Pos() (token.Pos)",
		"func (x *UnaryExpr) Pos() (token.Pos)",
		"func (x *BinaryExpr) Pos() (token.Pos)",
		"func (x *KeyValueExpr) Pos() (token.Pos)",
		"func (x *ArrayType) Pos() (token.Pos)",
		"func (x *StructType) Pos() (token.Pos)",
		"func (x *FuncType) Pos() (token.Pos)",
		"func (x *InterfaceType) Pos() (token.Pos)",
		"func (x *MapType) Pos() (token.Pos)",
		"func (x *ChanType) Pos() (token.Pos)",
		"func (x *BadExpr) End() (token.Pos)",
		"func (x *Ident) End() (token.Pos)",
		"func (x *Ellipsis) End() (token.Pos)",
		"func (x *BasicLit) End() (token.Pos)",
		"func (x *FuncLit) End() (token.Pos)",
		"func (x *CompositeLit) End() (token.Pos)",
		"func (x *ParenExpr) End() (token.Pos)",
		"func (x *SelectorExpr) End() (token.Pos)",
		"func (x *IndexExpr) End() (token.Pos)",
		"func (x *IndexListExpr) End() (token.Pos)",
		"func (x *SliceExpr) End() (token.Pos)",
		"func (x *TypeAssertExpr) End() (token.Pos)",
		"func (x *CallExpr) End() (token.Pos)",
		"func (x *StarExpr) End() (token.Pos)",
		"func (x *UnaryExpr) End() (token.Pos)",
		"func (x *BinaryExpr) End() (token.Pos)",
		"func (x *KeyValueExpr) End() (token.Pos)",
		"func (x *ArrayType) End() (token.Pos)",
		"func (x *StructType) End() (token.Pos)",
		"func (x *FuncType) End() (token.Pos)",
		"func (x *InterfaceType) End() (token.Pos)",
		"func (x *MapType) End() (token.Pos)",
		"func (x *ChanType) End() (token.Pos)",
		"func (*BadExpr) exprNode() ()",
		"func (*Ident) exprNode() ()",
		"func (*Ellipsis) exprNode() ()",
		"func (*BasicLit) exprNode() ()",
		"func (*FuncLit) exprNode() ()",
		"func (*CompositeLit) exprNode() ()",
		"func (*ParenExpr) exprNode() ()",
		"func (*SelectorExpr) exprNode() ()",
		"func (*IndexExpr) exprNode() ()",
		"func (*IndexListExpr) exprNode() ()",
		"func (*SliceExpr) exprNode() ()",
		"func (*TypeAssertExpr) exprNode() ()",
		"func (*CallExpr) exprNode() ()",
		"func (*StarExpr) exprNode() ()",
		"func (*UnaryExpr) exprNode() ()",
		"func (*BinaryExpr) exprNode() ()",
		"func (*KeyValueExpr) exprNode() ()",
		"func (*ArrayType) exprNode() ()",
		"func (*StructType) exprNode() ()",
		"func (*FuncType) exprNode() ()",
		"func (*InterfaceType) exprNode() ()",
		"func (*MapType) exprNode() ()",
		"func (*ChanType) exprNode() ()",
		"func NewIdent(name string) (*Ident)",
		"func IsExported(name string) (bool)",
		"func (id *Ident) IsExported() (bool)",
		"func (id *Ident) String() (string)",
		"func (s *BadStmt) Pos() (token.Pos)",
		"func (s *DeclStmt) Pos() (token.Pos)",
		"func (s *EmptyStmt) Pos() (token.Pos)",
		"func (s *LabeledStmt) Pos() (token.Pos)",
		"func (s *ExprStmt) Pos() (token.Pos)",
		"func (s *SendStmt) Pos() (token.Pos)",
		"func (s *IncDecStmt) Pos() (token.Pos)",
		"func (s *AssignStmt) Pos() (token.Pos)",
		"func (s *GoStmt) Pos() (token.Pos)",
		"func (s *DeferStmt) Pos() (token.Pos)",
		"func (s *ReturnStmt) Pos() (token.Pos)",
		"func (s *BranchStmt) Pos() (token.Pos)",
		"func (s *BlockStmt) Pos() (token.Pos)",
		"func (s *IfStmt) Pos() (token.Pos)",
		"func (s *CaseClause) Pos() (token.Pos)",
		"func (s *SwitchStmt) Pos() (token.Pos)",
		"func (s *TypeSwitchStmt) Pos() (token.Pos)",
		"func (s *CommClause) Pos() (token.Pos)",
		"func (s *SelectStmt) Pos() (token.Pos)",
		"func (s *ForStmt) Pos() (token.Pos)",
		"func (s *RangeStmt) Pos() (token.Pos)",
		"func (s *BadStmt) End() (token.Pos)",
		"func (s *DeclStmt) End() (token.Pos)",
		"func (s *EmptyStmt) End() (token.Pos)",
		"func (s *LabeledStmt) End() (token.Pos)",
		"func (s *ExprStmt) End() (token.Pos)",
		"func (s *SendStmt) End() (token.Pos)",
		"func (s *IncDecStmt) End() (token.Pos)",
		"func (s *AssignStmt) End() (token.Pos)",
		"func (s *GoStmt) End() (token.Pos)",
		"func (s *DeferStmt) End() (token.Pos)",
		"func (s *ReturnStmt) End() (token.Pos)",
		"func (s *BranchStmt) End() (token.Pos)",
		"func (s *BlockStmt) End() (token.Pos)",
		"func (s *IfStmt) End() (token.Pos)",
		"func (s *CaseClause) End() (token.Pos)",
		"func (s *SwitchStmt) End() (token.Pos)",
		"func (s *TypeSwitchStmt) End() (token.Pos)",
		"func (s *CommClause) End() (token.Pos)",
		"func (s *SelectStmt) End() (token.Pos)",
		"func (s *ForStmt) End() (token.Pos)",
		"func (s *RangeStmt) End() (token.Pos)",
		"func (*BadStmt) stmtNode() ()",
		"func (*DeclStmt) stmtNode() ()",
		"func (*EmptyStmt) stmtNode() ()",
		"func (*LabeledStmt) stmtNode() ()",
		"func (*ExprStmt) stmtNode() ()",
		"func (*SendStmt) stmtNode() ()",
		"func (*IncDecStmt) stmtNode() ()",
		"func (*AssignStmt) stmtNode() ()",
		"func (*GoStmt) stmtNode() ()",
		"func (*DeferStmt) stmtNode() ()",
		"func (*ReturnStmt) stmtNode() ()",
		"func (*BranchStmt) stmtNode() ()",
		"func (*BlockStmt) stmtNode() ()",
		"func (*IfStmt) stmtNode() ()",
		"func (*CaseClause) stmtNode() ()",
		"func (*SwitchStmt) stmtNode() ()",
		"func (*TypeSwitchStmt) stmtNode() ()",
		"func (*CommClause) stmtNode() ()",
		"func (*SelectStmt) stmtNode() ()",
		"func (*ForStmt) stmtNode() ()",
		"func (*RangeStmt) stmtNode() ()",
		"func (s *ImportSpec) Pos() (token.Pos)",
		"func (s *ValueSpec) Pos() (token.Pos)",
		"func (s *TypeSpec) Pos() (token.Pos)",
		"func (s *ImportSpec) End() (token.Pos)",
		"func (s *ValueSpec) End() (token.Pos)",
		"func (s *TypeSpec) End() (token.Pos)",
		"func (*ImportSpec) specNode() ()",
		"func (*ValueSpec) specNode() ()",
		"func (*TypeSpec) specNode() ()",
	}

	for _, user_query := range queries {
		query_ast, err := parse_user_function_query(user_query)
		if err != nil {
			fmt.Println(err)
		} else {
			fmt.Println(parse_ast_func_decl(nil, query_ast))
		}
	}
}
